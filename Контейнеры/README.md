# КОНТЕЙНЕРИЗАЦИЯ
_ _ _
- Метод легковесной виртуализации процессов
- В основе — изоляция процессов через cgroups, namespaces и другие механизмы
- Используется только одно ядро хостовой ОС
- Возможны ограничениā ресурсов по CPU, RAM, сети и т.д.
- Реализации:    
○ Docker    
○ LXC    
○ OpenVZ (Virtuozzo)    
    

Обыкновенно в контейнер записывают не более одного приложения и всё, что нужно для его  работы - библиотеки (зависимости). Из этого вытекают все плюсы контейнеризации - приложение "обособленно" от ОС, если в ОС происходят изменения, обновления и т.д то в контейнере ничего не изменится, все зависимости останутся прежними.

## Средства изоляции
1.Пространства имён (namespaces) - с помощью namespaces мы изолируем процессы в различных областях
- PID PID процессов
- NETWORK Сетевые устройства, стеки, порты и т.п.
- USER ID пользователей и групп
- MOUNT Точки монтирования
- IPC System V IPC, очереди сообщений POSIX
- UTS Имя хоста и доменное имя NIS
2. Контрольные группы (cgroups) ограничение ресурсов - контролируем выделяемы ресурс
- использование памяти, в том числе виртуальной
- приоритизация: разным группам можно выделить разное количество процессорного ресурса
- пропускной способности подсистемы ввода-вывода

### Chroot
 __Chroot (Changeroot)__ - это подмена корня файловой системы для процесса (системный вызов) подменяет местонахождение корня файловой системы, заключая программу в специально созданное ограниченное окружение (jail) Любые обращения к файлам за пределами этой системы будут запрещены.
    
- разбирает аргументы командной строки
- выполняет системный вызов chroot
- выполняет переход в другой каталог
- изменяет пользователя, от имени которого необходимо выполнить действия
- выполняет заданную команду, а если команды нет, то запускает интерпретатор командной строки по умолчанию

__Недостатки Chroot__
- Общее пространство процессов - процесс запущенный в chroot видит все остальные процессы
- Общая сеть - невозможно запустить изолированные серверы в разных chroot
- Нельзя назначить лимиты по ресурсам - в любой момент процесс из chroot может занять все ресурсы

__Где используется сейчас__
- Тестирование программ - chroot можно использовать для тестирования программ в безопасной среде, где они не могут повредить хост-систему
- Восстановление системы - chroot можно использовать для восстановления системы после сбоя или вредоносной атаки
- Управление разрешениями - сhroot можно использовать для ограничения доступа пользователей к определнным файлам и каталогам на сервере



По мимо chroot, существует системный вызов pivot_root. С точки зрения безопасности у pivot_root есть преимущества, поэтому на практике при реазлизации среды управления контейнерами будет
использован pivot_root

### Namespaces
Пространство имен(namespace) это возможность ядра Linux предоставить процессу изолированный инстанс глобальных ресурсов. Изменения в изолированном представлении глобальных ресурсов видны только членам этого пространства имен, и не видны остальным процессам.      


Namespaces (пространства имен) — это абстракция (программная прослойка) над физическими ресурсами. Если раньше процессы обращались напрямую к ресурсам, то с появлением namespaces, все запросы проходят через этот дополнительный слой абстракции.       


Пространства имён используются для изоляции процессов     


__Namespaces - типы__
1. Mount — абстракция над пространством имен для файловых систем.
- Разделить точки монтирования можно создав для контейнера его собственное пространство имен монтирования
2. Network — абстракция над сетью
- Благодаря пространству имен сети контейнер получает независимое представление сетевых интерфейсов и таблицы маршрутизации.
3. IPC — абстракция над межпроцессным взаимодействием.
- В Linux процессы могу обмениваться информацией с помощью доступа к разделяемой области памяти либо очереди сообщений. Для этого два процесса должны входить в одно пространство имен IPC
4. PID — абстракция над пространством номеров процессов.   
- Пространство имен идентификаторов процессов , ограничивает множество видимых идентификаторов для процесса в этом пространстве имен
5. User — абстракция над пространством пользователей.
- С помощью пространства имен пользователей процессы могут видеть другое представление идентификаторов пользователей и групп. Как и в случае с иденитфикаторами процессов, пользователи и группы получают другие идентификаторы внутри созданного пространства.
6. UTS (Unix Time Sharing) — абстракция над пространством hostname и NIS.
- Помещение процесса в отдельное пространство имен Unix Timesharing System UTS позволяет менять хост-имя или доменное имя для этого процесса независимо от хост-имени машины на которой он запущен.
7. Cgroup — используется как атрибут, корневой узел дерева cgroup.
-Не дает процессу видеть кофигурацию контрольный группы, которая по иерархии каталогов контрольных групп расположена выше, чем его собственная контрольная группа
8. Time     

Посмотреть пространство имен можно следующей командой:
```
sudo lsns
```



Команда **unshare** создает отдельное пространсво имен указанного типа, обеспечивая изоляцию определённых ресурсов и аспектов системы.     
Команда unshare полезна для тестирования и разработки, позволяя создавать изолированные окружения без необходимости использования полноценных контейнеров или виртуальных машин. Например, можно протестировать монтирование файловой системы или настройку сети в изолированном пространстве, не влияя на основную систему.      



__Примеры использования:__

1. Создание нового пространства имён для монтирования и запуск оболочки:
```
sudo unshare --mount /bin/bash
```
В этой новой оболочке можно монтировать и отмонтировать файловые системы без влияния на основную систему.

2. Создание нового пространства имён процессов и запуск оболочки:
```
sudo unshare --pid --fork /bin/bash
```
В этой оболочке можно запускать процессы с независимыми идентификаторами (PID), изолированными от основной системы.

3. Создание нового сетевого пространства имён и запуск оболочки:
```
sudo unshare --net /bin/bash
```
В этой оболочке можно настроить собственные сетевые интерфейсы и маршрутизацию, изолированные от основной системы.
   
#### cgroup
cgroup (control group) - (это "администратор ресурсов") возможность ядра Linux которая позволяет организовать процессы в иерархические группы, выполнять управление лимитами ресурсов различных типов (процессорное время, память, ввод - вывод), а так же производить мониторинг использования ресурсов для этих групп.     
Группировка ресурсов реализована в коде ядра, в то время как отслеживание и лимитирование выполняется с помощью набора подсистем (контроллеров) специфичных для ресурса.     

Каждый процесс в системы принадлежит определнный cgroup, посмотреть можем так:
```
shmel@lvm:~$ cat /proc/$$/cgroup 
0::/user.slice/user-1000.slice/session-258.scope
```

__cgroup - systemd__    
В современным мире для управления ресурсами процесса используют systemd    

По умолчанию systemd автоматически создает иерархию из slice, scope и services для предоставления унифицированной структуры для cgroup.     


Мы можем управлять распределением ресурсов с помощью команд systemctl или модифицируя файлы юнитов systemd     

- Service – это процесс или группа процессов которые systemd запускает основываясь на файле конфигурации юнита для этой службы. Сервис инкапсулирует указанные процессы, так что они могут запускаться и останавливаться как единый набор. имя_службы.service
- Scope – группа внешне созданных процессов. Обычно сессии пользователей, контейнеры, виртуальные машины трактуются как scope. имя_области.scope
- Slice – группа юнитов организованных в иерархию. Слайсы не содержат процессов, они организуют иерархию в которой размещаются области и сервисы. имя.slice

__Пример ограниченгие ресурсво сервису:__
```
systemctl set-property busy.service CPUQuota=50%
```
Файлы конфигурации контроля хранятся по пути /etc/systemd/system.control/busy.service.d/
