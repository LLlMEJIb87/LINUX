# SELinux
Security Enhanced Linux - система принудительного ( мандатного) контроля доступа     

__SELinux - особенности__
- Сложная система политик
- Непонятное разделение ответственности за создание политик
- Каждый ресурс должен быть связан с сервисом
- Высокая вероятность ошибки конфигурации
- Нет инструментов длā работы с политиками из коробки
- Низкие накладные расходы
- Безопасность никогда не бывает удобной


__Термины SELinux__
- Субъект - пользователь или процесс, то есть то, что выполняет действия в системе
- Объект - то над чем выполняются действия, то есть файлы, порты, сокеты и прочее
- Режимы (policy) SELinux:
     - targeted - набор политик по умолчанию (включает MCS)
     - minimum — вариант targeted, минимальный набор политик
     - mls - MLS (уровни секретности)
- TE (Type Enforcement, принудительная типизация доступа)
- Контекст безопасности (context) - метка, выглядит как строка переменной длины и хранится в расширенных атрибутах файловой системы. Объединяет в себе роли, типы и домены
- Домен (domain) - список действий, которые может выполнять процесс по отношению к различным объектам
- Тип (type) - атрибут объекта, который определяет, кто может получитъ к нему доступ
- Роль - атрибут, который определяет, в какие домены может входить пользователь, то есть какие домены пользователь имеет право запускать


__SELinux - инструменты__ - ставятся отдельно
1. Пакет setools-console
- sesearch
- seinfo
- findcon
- getsebool
- setsebool
2. Пакет policycoreutils-python
- audit2allow
- audit2why
3. Пакет policycoreutils-newrole
- newrole
4. Пакет selinux-policy-mls
- selinux-policy-mls

## Доступ
### Дискреционный механизм доступа
Дискреционный механизм доступа (DAC, Discretionary Access Control)
- Каждый файл имеет владельца
- Владелец может передавать права
- Владелец, группа, остальные
- Расширение: POSIX ACL

### Мандатный механизм доступа
Мандатный механизм доступа (MAC, Mandatory Access Control, матричное управление доступом)
- Явные права на объекты (файлы, устройства, сокеты, порты, процессы)
- Права определяются политиками, а не владельцем
- Модель управления правами домен-тип (домен процесса, тип данных)
- Вариант в Debian: AppArmor


#### Механизмы мандатного доступа
1. __MLS__ (Multi-Level Security, многоуровневая система безопасности)
- Модель Белла-Лападулы
- Уровни доступа (секретности)
- Объекты маркируются уровнями доступа         

Уровни секретности:
- Все субъекты и объекты имеют свой уровень допуска
- Субъект с определенным уровнем допуска имеет право читать и создавать (писать/обновлять) объекты с тем же уровнем допуска. Кроме того, он имеет право читать менее секретные объекты и создавать объекты с более высоким уровнем
- Субъект никогда не сможет создавать объекты с уровнем допуска ниже, чем он сам имеет, а также прочесть объект более высокого уровня допуска
- Краткая формулировка: «write up, read down» и «no write down, no read up»
- Применяется при повышенных требованиях к безопасности (гос. и военные)
- Работает в режиме mls


2. __MCS__ (Multi-Category Security, мультикатегорийная система безопасности)
- Данные разбиты на категории
- Объектам назначается метки категорий

MCS - категории объектов:
- Все субъекты и объекты имеют свою категорию
- Субъект получает доступ к своим разрешенным категориям
- Метки категорий расставляются по объектам и субъектам
- Работает в режиме targeted


3. __RBAC__ (Roles Based Access Control) - управление доступом на основе ролей

RBAC - управление по ролям:
- Контроль доступа к объектам файловой системы через роли, созданные на основании требований бизнеса или других критериев
- Роли могут быть разных типов и уровней доступа к объектам
- Пользователи по умолчанию:
   - system_u - системные процессы
   - root - системный администратор
   - user_u - все логины пользователей    

4. __TE__ (Type Enforcement) - принудительная типизация доступа
- Роль - набор правил
- Домен - то, что разрешено процессу (субъекту)
- Тип - набор правил для файла (объекта)
- Суть работы - сопоставление домена с типом через роль

<p align="center">
<image src="https://github.com/LLlMEJIb87/LINUX/blob/main/%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Pictures/TE.PNG">
</p>


__Наследование типов в SELinux__
- При создании файла в каталоге он наследует его тип
- Переход контекста (context transition) происходит при
наличии условий:
1. Целевой контекст файла является исполняемым для исходного домена
2. Целевой контекст файла помечен как точка входа для целевого домена
3. Исходный домен разрешен для перехода в целевой домен

<p align="center">
<image src="https://github.com/LLlMEJIb87/LINUX/blob/main/%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Pictures/perehod_konteksta.PNG">
</p>

Описание примера     
- В домен passwd_t можно войти выполнением приложений, маркированных типом passwd_exec_t (ls -Z /usr/bin/passwd)
- Только авторизованные домены passwd_t, могут записывать в файлы маркированные типом shadow_t
- Только авторизованные домены могут выполнять переход в домен passwd_t. Например, процесс sendmail запускается в домене sendmail_t и не имеет законных причин для запуска passwd, таким образом он не может выполнить
переход в домен passwd_t
- Процессы запущенные в домене passwd_t могут читать и записывать только в авторизованные файлы промаркированные типом etc_t или shadow_t. Это предотвращает приложение passwd от записи или чтения в другие файлы

__Контексты лежат вот по этому пути: /etc/selinux/targeted/contexts/files__

## Практика
- Точка в конце прав доступа явный признак, что у нас используется с SELinux 
```
[vagrant@selinux ~]$ ls -al
total 24
drwx------. 3 vagrant vagrant 132 Mar 16 00:47 .
drwxr-xr-x. 3 root    root     21 Oct  2 21:00 ..
-rw-------. 1 vagrant vagrant 678 Mar 16 00:38 .bash_history
```
- Добавив ключ Z к команде - мы увидим метки
```
[vagrant@selinux ~]$ ls -alZ
total 24
drwx------. 3 vagrant vagrant unconfined_u:object_r:user_home_dir_t:s0 132 Mar 16 00:47 .
drwxr-xr-x. 3 root    root    system_u:object_r:home_root_t:s0          21 Oct  2 21:00 ..
-rw-------. 1 vagrant vagrant unconfined_u:object_r:user_home_t:s0     678 Mar 16 00:38 .bash_history
-rw-r--r--. 1 vagrant vagrant unconfined_u:object_r:user_home_t:s0      18 Jan 23  2023 .bash_logout
```

__Команды SELinux__
- ls -Z /root - просмотр контекста безопасности каталога
- semanage login -l -  информация о правах пользователей
- ls -Z /usr/sbin/nginx - контекст безопасности объекта
- ps -Z 12345 - контекст безопасности процесса
- sesearch -A -s httpd_t | grep 'allow httpd_t' — разрешение правила для типа httpd_t
- sesearch -s httpd_t -t httpd_exec_t -c file -p execute -Ad — ищем правила преобразования по типам


### Режимы работы
- Конфиг: /etc/selinux/config
- Статус: sestatus или getenforce
- Отключение: setenforce 0
- Включние: setenforce 1
- Просмотр ошибок: journalctl -t setroubleshoot --since=14:20

В конфиге есть возможность перевести режим работы SELinux из enforcing - когда он работает и запрещает, в  permissive - когда он работает, но не запрещает и ошибки пишет в лог, тем самым можно првоерить проблема с которой мы столкнулись в SELinux или нет. Режим работы меняетя на лету. (кроме Disabled) Дополнительно для отладки можно менять режим на permissive только для определенной метки, а не для всей системы:
```
semanage permissive -a httpd_t #Включить permissive
semanage permissive -d httpd_t #Отключить permissive
```

### Изменение контекстов
Изменение контекстов:
- Меняем (временно) тип в контексте каталога: chcon -R -t type /home/user
- Проверяем контекст каталога: ls -Z /home/user
- Восстанавливаем контекст каталога: restorecon -v /home/user
- Постоянное изменение контекста:
   - semanage fcontext -a options file-name|directory-name
   - restorecon -v file-name|directory-name

### Создание модуля на основе лога
1. Очищаем audit.log: echo > /var/log/audit/audit.log (в новых системах используем jpurnald)
2. Включаем в SELinux режим permissive: setenforce 0
3. Запускаем приложение и получаем ошибки в audit.log
4. Смотрим ошибки и рекомендации в audit.log: audit2why < /var/log/audit/audit.log
5. Формируем модуль с правилами для SELinux из данных лога audit2allow -M httpd_add --debug < /var/log/audit/audit.log
6. Загружаем модуль (сохраняется после перезагрузки) semodule -i httpd_add.pp

### Параметризованные политики
- Представляет из себя политики, которые описаны переменными с булевым типом (on/off)
- Управлятся утилитами: getsebool и setsebool
- Просмотр политик в отношении сервиса samba:    
 getsebool -a | grep samba
- Меняем значение выбранной политики (постоянно):    
 setsebool -P samba_share_fusefs on
