# Загрузка OS
## UEFI
1. Нажатие кнопки питания: ПК включается, электричество подаётся на материнскую плату.
2. Запуск UEFI: Код UEFI, который хранится в чипе прошивки на материнской плате, начинает исполняться. Этот чип использует NVRAM как "записную книжку" с настройками.
3. Тест оборудования (POST): UEFI проверяет критические компоненты — процессор, память, диски и т.д. Если всё ок, идём дальше.
4. Поиск загрузчика: UEFI смотрит в NVRAM, где записано, какой файл загрузчика и на каком разделе искать (например, /EFI/ubuntu/grubx64.efi на EFI-партиции).
5. Запуск загрузчика: Если загрузчик найден, UEFI передаёт управление ему — запускается код GRUB (или другого загрузчика, если он настроен).
- UEFI читает файл загрузчика с диска (это бинарный файл в формате .efi) и загружает его в оперативную память компьютера.
- UEFI готовит минимальную информацию для загрузчика: сообщает, где находится оборудование (через таблицы ACPI), какие устройства доступны (диски, память) и как с ними работать. 
- UEFI выполняет команду "jump" (прыжок) в assembler-подобной логике. Это инструкция процессору: "Теперь начинай выполнять код, который лежит вот по этому адресу в памяти" (где загружен grubx64.efi).
- Как только процессор начинает выполнять код загрузчика, UEFI перестаёт быть активным. Теперь GRUB (или другой загрузчик) "рулит" — он инициализирует себя, читает свои конфиги (например, /boot/grub/grub.cfg) и продолжает процесс загрузки ядра.

## GRUB
1. Инициализация GRUB:
- Как только процессор "прыгает" на адрес в памяти, где лежит код GRUB (например, grubx64.efi для UEFI), загрузчик начинает исполняться.
- GRUB инициализирует себя: проверяет, в каком режиме он работает (UEFI или BIOS), определяет доступное оборудование через информацию, оставленную UEFI (например, таблицы памяти и устройств).
2. Чтение конфигурации:
- GRUB ищет свой конфигурационный файл, чтобы понять, что делать дальше. В Ubuntu это обычно /boot/grub/grub.cfg.
- Этот файл находится на диске (например, в корневом разделе или отдельном /boot), и GRUB использует встроенные драйверы файловых систем (ext4, FAT и т.д.), чтобы его прочитать.
- В grub.cfg прописаны команды: какое ядро загружать, какие параметры ему передать, и есть ли меню для выбора.
3. Отображение меню (если настроено):
- Если в настройках GRUB (в файле /etc/default/grub) указано показывать меню (например, GRUB_TIMEOUT=5), ты увидишь экран с выбором:
- Доступные ядра (например, Ubuntu, with Linux 5.15.0-73-generic).
- Режим восстановления (Recovery Mode).
- Другие ОС, если они есть (например, Windows).
- Если таймаут = 0 или меню отключено, GRUB сразу грузит вариант по умолчанию.
4. Поиск ядра и начального RAM-диска:
- GRUB читает из grub.cfg пути к файлам ядра (обычно /boot/vmlinuz-X.XX.X-XX-generic) и начального RAM-диска (/boot/initrd.img-X.XX.X-XX-generic).
- Эти файлы тоже лежат на диске, и GRUB загружает их в оперативную память, как UEFI делал с самим GRUB.
5. Копирование в память:
Ядро (vmlinuz) — это сжатый исполняемый файл, который GRUB распаковывает и размещает в определённой области RAM.
initrd (initial ramdisk) — это временная файловая система, тоже загружается в RAM. Она нужна ядру, чтобы найти драйверы для работы с диском и корневой файловой системой.
6. Передача параметров ядра:
- GRUB передаёт ядру командную строку (kernel command line), которая указана в grub.cfg. Например:
- root=UUID=xxxx-xxxx-xxxx — где искать корневой раздел.
- ro — монтировать корень только для чтения сначала.
- quiet splash — скрыть лишние сообщения и показать заставку (в Ubuntu Desktop).
7. Передача управления ядру:
- GRUB, как и UEFI до него, выполняет "прыжок" — указывает процессору адрес в памяти, где лежит распакованное ядро, и говорит: "Теперь ты главный".
- Технически это вызов точки входа ядра (entry point), например, функции start_kernel() в коде Linux.
8. GRUB отключается:
- После передачи управления GRUB завершает свою работу и больше не активен. Всё, что он сделал — это подготовил ядро и initrd в памяти и "нажал старт".

## Загрузка Ядра

1. Старт ядра:
- Процессор начинает выполнять код ядра с его точки входа (entry point), например, функции start_kernel() в исходниках Linux.
- Ядро — это сжатый бинарный файл (vmlinuz — "vmlinux zipped"), который GRUB уже распаковал в RAM. Теперь оно "разворачивается" и инициализируется.
2. Инициализация процессора и памяти:
- Ядро настраивает процессор: включает защищённый режим (protected mode) или длинный режим (long mode) для 64-битных систем, активирует поддержку многозадачности.
- Инициализирует управление памятью: создаёт таблицы страниц (page tables), чтобы программы могли безопасно работать с RAM.
- Определяет, сколько памяти доступно, и резервирует её для своих нужд.
3. Обнаружение оборудования:
Ядро сканирует железо через информацию от UEFI (например, таблицы ACPI и UEFI Boot Services, пока они ещё доступны).
Находит базовые устройства: контроллеры дисков, таймеры, прерывания (IRQ).
4. Выход из UEFI (если UEFI-режим):
- Ядро вызывает ExitBootServices(), окончательно отключая UEFI. Теперь оно полностью управляет системой, и прошивка больше не вмешивается.

**Использование initrd**      
5. Распаковка initrd:
- Ядро видит адрес initrd в RAM (переданный GRUB) и распаковывает его как временную файловую систему в память (обычно в ramfs).
- Монтирует её как корень (/) — пока это единственная "система", которую ядро видит.
6. Запуск /init из initrd:
- Ядро исполняет скрипт /init из initrd. Этот скрипт:
- Загружает модули ядра (например, modprobe ahci для SATA-дисков или modprobe ext4 для файловой системы).
- Настраивает доступ к корневому разделу (по UUID или пути из командной строки ядра).
- Может выполнять дополнительные задачи, например, расшифровку диска (если используется LUKS).
7. Переключение на корневую систему:
- Как только initrd подготовил доступ к настоящему корневому разделу (например, /dev/sda1), ядро монтирует его в /root.
- Выполняется "pivot_root" — временный корень в RAM заменяется на настоящий с диска.
- После этого initrd освобождается из памяти, он больше не нужен.

**Запуск системы**        
8. Запуск первого процесса:
- Ядро ищет программу /sbin/init на корневой файловой системе и запускает её как процесс с PID 1.
- В Ubuntu это systemd (символическая ссылка на /lib/systemd/systemd).
9. Передача управления systemd:
- С этого момента ядро "отходит на второй план" — оно продолжает работать как основа системы (управляет оборудованием, памятью, процессами), но управление пользовательским уровнем переходит к systemd.
- systemd начинает запускать службы, монтировать диски и доводить систему до рабочего состояния.

## Инициализация системы

После того как ядро завершило свою работу — инициализировало оборудование, использовало initrd для доступа к корневой файловой системе и передало управление первому процессу (/sbin/init, в Ubuntu это systemd) — начинается следующий этап: инициализация системы. Теперь systemd берёт на себя управление, и система превращается из "голого ядра" в полноценную рабочую ОС    
1. Запуск systemd как PID 1:
- Ядро запускает /sbin/init, который в Ubuntu является символической ссылкой на /lib/systemd/systemd.
- systemd становится первым процессом (PID 1) и "дирижёром" всей системы. Его задача — довести систему до рабочего состояния, запуская службы и настраивая окружение.
2. Чтение целей (targets):
- systemd работает с так называемыми "юнитами" (unit files) — это конфигурационные файлы, которые описывают, что и как запускать.
- Главная цель по умолчанию в Ubuntu — это multi-user.target (для серверов, текстовый режим) или graphical.target (для десктопов с графическим интерфейсом).
- Эти цели задаются в /etc/systemd/system/default.target (символическая ссылка).
3. Монтирование файловых систем:
- systemd читает файл /etc/fstab и монтирует все указанные там разделы, например:     
/home (если отдельный раздел).     
/tmp, /var и т.д.    
- Также монтируются виртуальные файловые системы, такие как /proc, /sys, /dev, которые нужны для работы ядра и программ.
